<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Java 程序设计 LAB06 #  实验目的 #   简单了解 Object 类 掌握良好重写 Object 类中方法的能力 简单了解内部类、匿名类  实验题目 #   本实验假设你明白：
 涉及内部类时的初始化过程 内部类能够访问其外部类的所有属性和方法 构造内部类必须先构造外部类对象 嵌套类（静态内部类）只能够访问外部类的静态属性和方法 嵌套类可以直接通过类名构造 匿名内部类和局部内部类中直接使用的外部数据必须是 final 的（除非是匿名类的方法 的参数） 上述这些语法层面的东西，可以尝试自行证明。    本次实验不会涉及以下内部类的常用技巧：
 回调与闭包 事件与控制框架  也不会涉及以下内部类的边角情况：
 内部类的继承与覆盖 多重嵌套的内部类   Question01 InnerClass1 代码填空 #  阅读下面这段代码：
class Outer {  public int num = 10;   class Inner { 	public int num = 20;  	public void show() { 	int num = 30; 	System."><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content><meta property="og:description" content="Java 程序设计 LAB06 #  实验目的 #   简单了解 Object 类 掌握良好重写 Object 类中方法的能力 简单了解内部类、匿名类  实验题目 #   本实验假设你明白：
 涉及内部类时的初始化过程 内部类能够访问其外部类的所有属性和方法 构造内部类必须先构造外部类对象 嵌套类（静态内部类）只能够访问外部类的静态属性和方法 嵌套类可以直接通过类名构造 匿名内部类和局部内部类中直接使用的外部数据必须是 final 的（除非是匿名类的方法 的参数） 上述这些语法层面的东西，可以尝试自行证明。    本次实验不会涉及以下内部类的常用技巧：
 回调与闭包 事件与控制框架  也不会涉及以下内部类的边角情况：
 内部类的继承与覆盖 多重嵌套的内部类   Question01 InnerClass1 代码填空 #  阅读下面这段代码：
class Outer {  public int num = 10;   class Inner { 	public int num = 20;  	public void show() { 	int num = 30; 	System."><meta property="og:type" content="article"><meta property="og:url" content="https://Super-BUAA-2021.github.io/Java-HomeWork/docs/OOP-LAB/LAB06/"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2022-04-15T16:55:45+08:00"><title>Lab06 | 面向对象的程序设计</title><link rel=manifest href=/Java-HomeWork/manifest.json><link rel=icon href=/Java-HomeWork/favicon.png type=image/x-icon><link rel=stylesheet href=/Java-HomeWork/book.min.82c5dbd23447cee0b4c2aa3ed08ce0961faa40e1fa370eee4f8c9f02e0d46b5f.css integrity="sha256-gsXb0jRHzuC0wqo+0Izglh+qQOH6Nw7uT4yfAuDUa18=" crossorigin=anonymous><script defer src=/Java-HomeWork/flexsearch.min.js></script>
<script defer src=/Java-HomeWork/en.search.min.922e62f0f4c0cf8cbb06c882a63a37b1d1cf1269e2ac9af9aa6e5e82a5557af4.js integrity="sha256-ki5i8PTAz4y7BsiCpjo3sdHPEmnirJr5qm5egqVVevQ=" crossorigin=anonymous></script>
<script defer src=/Java-HomeWork/sw.min.e3fe574a0a73f41ab65bfa422f0900e37d2b9d2ca50572cea3deaf158cc4bdee.js integrity="sha256-4/5XSgpz9Bq2W/pCLwkA430rnSylBXLOo96vFYzEve4=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/Java-HomeWork/><span>面向对象的程序设计</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=/Java-HomeWork/docs/OOP-LAB/>Oop Lab</a><ul><li><a href=/Java-HomeWork/docs/OOP-LAB/LAB00/>Lab00</a></li><li><a href=/Java-HomeWork/docs/OOP-LAB/LAB01/>Lab01</a></li><li><a href=/Java-HomeWork/docs/OOP-LAB/LAB02/>Lab02</a></li><li><a href=/Java-HomeWork/docs/OOP-LAB/LAB03/>Lab03</a></li><li><a href=/Java-HomeWork/docs/OOP-LAB/LAB04/>Lab04</a></li><li><a href=/Java-HomeWork/docs/OOP-LAB/LAB05/>Lab05</a></li><li><a href=/Java-HomeWork/docs/OOP-LAB/LAB06/ class=active>Lab06</a></li><li><a href=/Java-HomeWork/docs/OOP-LAB/LAB07/>Lab07</a></li><li><a href=/Java-HomeWork/docs/OOP-LAB/LAB08/>Lab08</a></li><li><a href=/Java-HomeWork/docs/OOP-LAB/LAB09/>Lab09</a></li><li><a href=/Java-HomeWork/docs/OOP-LAB/LAB10/>Lab10</a></li><li><a href=/Java-HomeWork/docs/OOP-LAB/TEMPLATE/>Template</a></li></ul></li><li><span>Cts</span><ul><li><a href=/Java-HomeWork/docs/CTS/CTS-1/>Cts 1</a></li><li><a href=/Java-HomeWork/docs/CTS/CTS-2/>Cts 2</a></li><li><a href=/Java-HomeWork/docs/CTS/CTS-3/>Cts 3</a></li><li><a href=/Java-HomeWork/docs/CTS/CTS-4/>Cts 4</a></li></ul></li><li><a href=/Java-HomeWork/docs/Resource/>Resource</a><ul></ul></li></ul><ul><li><a href=https://github.com/Super-BUAA-2021/Java-HomeWork target=_blank rel=noopener>Github</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/Java-HomeWork/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Lab06</strong>
<label for=toc-control><img src=/Java-HomeWork/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#java-程序设计-lab06>Java 程序设计 LAB06</a><ul><li><a href=#实验目的>实验目的</a></li><li><a href=#实验题目>实验题目</a><ul><li><a href=#question01-innerclass1-代码填空>Question01 InnerClass1 <code>代码填空</code></a></li><li><a href=#question02-innerclass2-代码填空>Question02 InnerClass2 <code>代码填空</code></a></li><li><a href=#question03-匿名类的-shapefactory-编程题旧题>Question03 匿名类的 ShapeFactory <code>编程题|旧题</code></a><ul><li><a href=#题外话>题外话：</a></li></ul></li><li><a href=#question04-shapesequence-编程题>Question04 ShapeSequence <code>编程题</code></a><ul><li><a href=#注意>注意：</a></li><li><a href=#题外话-1>题外话：</a></li></ul></li></ul></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=java-程序设计-lab06>Java 程序设计 LAB06
<a class=anchor href=#java-%e7%a8%8b%e5%ba%8f%e8%ae%be%e8%ae%a1-lab06>#</a></h1><h2 id=实验目的>实验目的
<a class=anchor href=#%e5%ae%9e%e9%aa%8c%e7%9b%ae%e7%9a%84>#</a></h2><ul><li>简单了解 Object 类</li><li>掌握良好重写 Object 类中方法的能力</li><li>简单了解内部类、匿名类</li></ul><h2 id=实验题目>实验题目
<a class=anchor href=#%e5%ae%9e%e9%aa%8c%e9%a2%98%e7%9b%ae>#</a></h2><blockquote><p>本实验假设你明白：</p><ul><li>涉及内部类时的初始化过程</li><li>内部类能够访问其外部类的所有属性和方法</li><li>构造内部类必须先构造外部类对象</li><li>嵌套类（静态内部类）只能够访问外部类的静态属性和方法</li><li>嵌套类可以直接通过类名构造</li><li>匿名内部类和局部内部类中直接使用的外部数据必须是 final 的（除非是匿名类的方法 的参数）
上述这些语法层面的东西，可以尝试自行证明。</li></ul></blockquote><blockquote><p>本次实验不会涉及以下内部类的常用技巧：</p><ul><li>回调与闭包</li><li>事件与控制框架</li></ul><p>也不会涉及以下内部类的边角情况：</p><ul><li>内部类的继承与覆盖</li><li>多重嵌套的内部类</li></ul></blockquote><h3 id=question01-innerclass1-代码填空>Question01 InnerClass1 <code>代码填空</code>
<a class=anchor href=#question01-innerclass1-%e4%bb%a3%e7%a0%81%e5%a1%ab%e7%a9%ba>#</a></h3><p>阅读下面这段代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Outer</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> num <span style=color:#f92672>=</span> 10<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Inner</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> num <span style=color:#f92672>=</span> 20<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>show</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>	  <span style=color:#66d9ef>int</span> num <span style=color:#f92672>=</span> 30<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>	  System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span><span style=color:#75715e>/*???*/</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>	  System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span><span style=color:#75715e>/*???*/</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>	  System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span><span style=color:#75715e>/*???*/</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Test</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span><span style=color:#f92672>(</span>String<span style=color:#f92672>[]</span> args<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>	Outer<span style=color:#f92672>.</span><span style=color:#a6e22e>Inner</span> oi <span style=color:#f92672>=</span> <span style=color:#75715e>/*???*/</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>	oi<span style=color:#f92672>.</span><span style=color:#a6e22e>show</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><ul><li>在 <code>Code/Question01/Test.java</code> 中的注释部分填代码，使程序先后输出 30、20、10。</li><li>注意：<ul><li>不允许修改已经有的代码。</li><li>考察的是内部类的构造以及访问外部类的方法，请<strong>不要用加减运算</strong>这种操作。</li></ul></li></ul><h3 id=question02-innerclass2-代码填空>Question02 InnerClass2 <code>代码填空</code>
<a class=anchor href=#question02-innerclass2-%e4%bb%a3%e7%a0%81%e5%a1%ab%e7%a9%ba>#</a></h3><p>阅读下面这段代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>Inter</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>show</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Outer</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/*???*/</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Test</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span><span style=color:#f92672>(</span>String<span style=color:#f92672>[]</span> args<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>	Outer<span style=color:#f92672>.</span><span style=color:#a6e22e>method</span><span style=color:#f92672>().</span><span style=color:#a6e22e>show</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><ul><li>在 <code>Code/Question02/Test.java</code> 中的注释部分填代码，使程序输出"DuluDulu"。</li><li>注意：<ul><li>不允许修改已经有的代码。</li><li>考察的是匿名类，但是用内部类也可以实现</li></ul></li></ul><h3 id=question03-匿名类的-shapefactory-编程题旧题>Question03 匿名类的 ShapeFactory <code>编程题|旧题</code>
<a class=anchor href=#question03-%e5%8c%bf%e5%90%8d%e7%b1%bb%e7%9a%84-shapefactory-%e7%bc%96%e7%a8%8b%e9%a2%98%e6%97%a7%e9%a2%98>#</a></h3><p>在前面实验的 <code>Shape</code> 的基础上，定义一个满足如下需求的 <code>IShapeFactory</code> 接口：</p><ul><li>具有方法 <code>Shape makeShape(double a, double b)</code> ，返回一个由 a 和 b 指定大小的 形状；<ul><li>参数不合法时，返回 null 或抛出异常</li></ul></li></ul><p>用单例模式+工厂方法模式的思想修改矩形、椭圆、菱形类：</p><ul><li>每一个类都增设一个 <code>private static IShapeFactory factory</code> 字段<ul><li>类中的 factory 用于生成该类的形状对象<ul><li>比如 Rectangle 类中的 factory，其 makeShape 方法返回 Rectangle 对象</li></ul></li><li>直接使用匿名类为 factory 进行静态初始化，不允许像 ShapeFactory2 那样定义工厂类</li></ul></li><li>进行其他的修改，使外界的其他类能够获取到 factory 并成功构造形状对象</li></ul><p>选择你认为合适的方式编写测试类，：</p><ul><li>你的测试类应该能够覆盖到所有等价类。</li><li>测试形式可以是单元测试，被测对象的形式可以参考之前实验中的 <code>ShapeFactoriesTest.makeShape</code> 方法。</li><li>在代码注释中（或者与代码一起提交一个 readme），描述你的测试计划</li></ul><h4 id=题外话>题外话：
<a class=anchor href=#%e9%a2%98%e5%a4%96%e8%af%9d>#</a></h4><p>使用匿名类，依然是为每一个形状创建了一个对应的工厂，因此本质上依然是工厂方法模式，区别在于不用显式定义新的类（据说编码过程中，起名字是最麻烦的事情）。
工厂方法模式的应用中，每一种工厂通常只有一个实例，因此它经常和单例模式一起被使用。</p><h3 id=question04-shapesequence-编程题>Question04 ShapeSequence <code>编程题</code>
<a class=anchor href=#question04-shapesequence-%e7%bc%96%e7%a8%8b%e9%a2%98>#</a></h3><blockquote><p>这是一个主动要求大家造轮子的题，因此不允许继承或组合任何 java 自带的容器（除了数组）。
本题假设大家在算法上机时能够较为熟练的使用 C++中 STL 容器，并至少对变长容器的迭代访问有一定了解。</p></blockquote><p>在 Shape 的基础上，定义一个满足如下需求的 <code>ShapeSequence</code> 类：</p><ul><li>具有属性 <code>private Shape[] shapes</code></li><li>构造方法 <code>ShapeSequence(int size)</code><ul><li>size 用于指定 shapes 的最大长度，如果 size 是负数，那么按照 0 来处理。</li><li>构造方法中应当对 shapes 进行初始化赋值，在其他过程中 shapes 的大小不
应该被改变</li></ul></li><li>方法 <code>public void add(Shape shape)</code><ul><li>向 shapes 中添加一个新的元素</li><li>当 shapes 被填满时，什么都不做</li></ul></li><li>方法 <code>public String toString()</code><ul><li>返回这个容器的字符串表达，格式为 <code>[Type, Type,...]</code></li><li>格式中的 Type 是形状类型的全小写英文单词，比如 <code>rectangle、ellipse</code></li></ul></li><li>方法 <code>public SequenceIterator iterator() {return new SequenceIterator();}</code></li><li>具有内部类 <code>private class SequenceIterator</code>，它用于序列遍历的迭代器<ul><li>默认构造方法，在被构造时，迭代器指向的位置代表数组下标 0</li><li>方法 <code>public boolean isEnd()</code>，迭代器完成遍历时，返回 true<ul><li>完成遍历不代表迭代器指向了最后一个元素，而是指向了最后一个元素的下一个位置</li></ul></li><li>方法 <code>public Shape current()</code>，返回当前迭代器指向位置的 Shape 对象<ul><li>isEnd()是 true 时，访问 current 是非法操作</li></ul></li><li>方法 <code>public void moveNext()</code>，使迭代器移动到下一个元素的位置<ul><li>isEnd()是 true 时，什么都不做</li></ul></li><li>方法 <code>public boolean equals(Object o)</code>，当 o 是 SequenceItetator 类型的、且
o 和 this 的外部类对象相同、且 o 和 this 的位置相同时，返回 true</li></ul></li></ul><p>编写测试类并描述你的测试计划</p><h4 id=注意>注意：
<a class=anchor href=#%e6%b3%a8%e6%84%8f>#</a></h4><p><strong>toString 和 equals 是 override 继承自 Object 的方法，尽量避免出现诸如 ToString、 equals 的参数类型不是 Object（这种情况会算作 overload）等情况</strong></p><p>题目中省略了一些实现上必要但是方式不唯一的属性：比如你可以在 <code>ShapeSequence</code> 类中声明一个 int 属性来表示当前容器被填充到了什么位置；给 <code>SequenceIterator</code> 一个 int 属性表示当前迭代器指向的位置，当使用 <code>isEnd</code> 时，判断迭代器位置和外部类容器的填充位置进行比较。</p><h4 id=题外话-1>题外话：
<a class=anchor href=#%e9%a2%98%e5%a4%96%e8%af%9d-1>#</a></h4><ul><li>本题的目的是进行内部类、Object 相关的综合实践，通过使用自定义的迭代器和容器提前复习 C++基础并理解一些基础概念。</li><li>后续容器和泛型课程中，会引入可变长容器以及匿名类实现的迭代器。</li><li>虽然我们上机并不评测程序的性能，但是在实现本题的 toString 时，还是推荐考虑使用 StringBuilder。</li><li>你可以考虑一下不使用内部类时要如何实现迭代器，内部类为这种数据访问是否带来了足够的便利？</li><li>为什么 SequenceIterator 被限定为了 private</li></ul></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/alex-shpak/hugo-book/commit/cf33828b3d8e146c96fee899b02cab99df10758d title="Last modified by withinlover | April 15, 2022" target=_blank rel=noopener><img src=/Java-HomeWork/svg/calendar.svg class=book-icon alt=Calendar>
<span>April 15, 2022</span></a></div><div><a class="flex align-center" href=https://github.com/alex-shpak/hugo-book/edit/main/exampleSite/content/docs/OOP-LAB/LAB06.md target=_blank rel=noopener><img src=/Java-HomeWork/svg/edit.svg class=book-icon alt=Edit>
<span>Edit this page</span></a></div></div><script>(function(){function e(n){const e=window.getSelection(),t=document.createRange();t.selectNodeContents(n),e.removeAllRanges(),e.addRange(t)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script><script>MathJax={tex:{inlineMath:[["$","$"]]},displayMath:[["$$","$$"],["[[","]]"]],svg:{fontCache:"global"}}</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#java-程序设计-lab06>Java 程序设计 LAB06</a><ul><li><a href=#实验目的>实验目的</a></li><li><a href=#实验题目>实验题目</a><ul><li><a href=#question01-innerclass1-代码填空>Question01 InnerClass1 <code>代码填空</code></a></li><li><a href=#question02-innerclass2-代码填空>Question02 InnerClass2 <code>代码填空</code></a></li><li><a href=#question03-匿名类的-shapefactory-编程题旧题>Question03 匿名类的 ShapeFactory <code>编程题|旧题</code></a><ul><li><a href=#题外话>题外话：</a></li></ul></li><li><a href=#question04-shapesequence-编程题>Question04 ShapeSequence <code>编程题</code></a><ul><li><a href=#注意>注意：</a></li><li><a href=#题外话-1>题外话：</a></li></ul></li></ul></li></ul></li></ul></nav></div></aside></main></body></html>